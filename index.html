<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2D Water Ripples</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden; /* 스크롤바 방지 */
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script>
    // 2D Water Ripples
    // The Coding Train / Daniel Shiffman
    // https://thecodingtrain.com/CodingChallenges/102-2d-water-ripple.html
    // https://youtu.be/BZUdGqeOD0w
    // https://editor.p5js.org/codingtrain/sketches/tYXtzNSl

    // Algorithm: https://web.archive.org/web/20160418004149/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm

    let cols;
    let rows;
    let current; // = new float[cols][rows];
    let previous; // = new float[cols][rows];

    let dampening = 0.99;

    const density = 'Ñ@#W$9876543210?!abc;:+=-,._ ';
    let scl = 8; // 아스키 아트 렌더링 해상도
    let physicsScl = 8; // 물리 시뮬레이션 해상도 (값이 클수록 빠름)

    function setup() {
      pixelDensity(1);
      createCanvas(windowWidth, windowHeight);
      // 시뮬레이션 해상도에 맞춰 배열 크기 설정
      cols = floor(width / physicsScl);
      rows = floor(height / physicsScl);
      current = new Array(cols).fill(0).map(n => new Array(rows).fill(0));
      previous = new Array(cols).fill(0).map(n => new Array(rows).fill(0));
      textFont('monospace');
      textSize(scl);
    }

    function mouseDragged() {
      // 마우스 좌표를 시뮬레이션 격자 좌표로 변환
      let mx = floor(mouseX / physicsScl);
      let my = floor(mouseY / physicsScl);
      if (mx >= 1 && mx < cols - 1 && my >= 1 && my < rows - 1) {
        previous[mx][my] = 2500;
      }
    }

    function draw() {
      background(0);

      // 저해상도 격자에서 물리 계산을 수행하여 성능 향상
      for (let i = 1; i < cols - 1; i++) {
        for (let j = 1; j < rows - 1; j++) {
          current[i][j] =
            (previous[i - 1][j] +
              previous[i + 1][j] +
              previous[i][j - 1] +
              previous[i][j + 1]) / 2 - current[i][j];
          current[i][j] = current[i][j] * dampening;
        }
      }

      // 아스키 렌더링
      fill(255);
      noStroke();
      for (let j = 0; j < height; j += scl) {
        for (let i = 0; i < width; i += scl) {
          // 렌더링 좌표를 시뮬레이션 격자 좌표로 변환하여 값을 가져옴
          let gridX = floor(i / physicsScl);
          let gridY = floor(j / physicsScl);
          let val = current[gridX][gridY];
          // 파동의 세기(val)를 density 문자열의 인덱스로 변환
          const len = density.length;
          const charIndex = floor(map(constrain(val, 0, 255), 0, 255, len - 1, 0));
          text(density.charAt(charIndex), i, j);
        }
      }
      
      let temp = previous;
      previous = current;
      current = temp;
    }
  </script>
</body>
</html>